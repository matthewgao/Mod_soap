/* 
**  mod_mod_soap.c -- Apache sample mod_soap module
**  [Autogenerated via ``apxs -n mod_soap -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_mod_soap.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /mod_soap in as follows:
**
**    #   apache2.conf
**    LoadModule mod_soap_module modules/mod_mod_soap.so
**    <Location /mod_soap>
**    SetHandler mod_soap
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /mod_soap and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/mod_soap 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_mod_soap.c
*/ 
#include <ctype.h>
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include <apr_xml.h>
#include "test.h"

#define apr_isspace(c)   (isspace(((unsigned char)(c))))

extern  module AP_MODULE_DECLARE_DATA soap_module;
extern "C" int ap_xml_parse_input	(request_rec * r,apr_xml_doc ** pdoc);

const char * soap_xml_get_cdata(const apr_xml_elem *elem, apr_pool_t *pool,
                              int strip_white);
/* The sample content handler */
void dump_xml(request_rec *r, apr_xml_elem *root){

        if(root==NULL)
                return;
        if(root->name!=NULL)
                ap_rprintf(r," Name:%s  \n", root->name);
        if(root->lang!=NULL)
                ap_rprintf(r," lang:%s  \n", root->lang );
        if(root->attr!=NULL)
                ap_rprintf(r," Attr: %s:%s \n", root->attr->name,root->attr->value );
        if(root->first_cdata.first!=NULL){
                apr_text *itr=root->first_cdata.first;
                for(;itr!=NULL;itr=itr->next)
                        ap_rprintf(r," cdata:%s  \n", itr->text);
        }
        if(root->following_cdata.first!=NULL){
                apr_text *itr=root->following_cdata.first;
                for(;itr!=NULL;itr=itr->next)
                        ap_rprintf(r," following_cdata:%s  \n", itr->text);
        }
 /*       
        const char * buf=soap_xml_get_cdata(root, r->pool,1);
        if(buf==NULL)
                ap_rprintf(r,"Buf is NULL");
        else
                ap_rprintf(r," Value: %s \n", buf );
 */
        dump_xml(r,root->first_child);
        dump_xml(r,root->next);
        
       // dump_xml(r,root->parent);       
}


/* find and return the (unique) child with a given DAV: tagname */
apr_xml_elem *soap_find_elem(const apr_xml_elem *elem, const char *tagname)
{
    apr_xml_elem *find = (apr_xml_elem *) elem;
    for (; find; find = find->next)
	/* FIXME namespace
	if (child->ns == AP_XML_NS_DAV_ID && !strcmp(child->name, tagname))
	*/  
	if (!strcmp(find->name, tagname))
	    return find;
    return NULL;
}

/* find and return the (unique) child with a given DAV: tagname */
apr_xml_elem *soap_find_child(const apr_xml_elem *elem, const char *tagname)
{
    apr_xml_elem *child = elem->first_child;
    return soap_find_elem(child, tagname);
}

const char * soap_xml_get_cdata(const apr_xml_elem *elem, apr_pool_t *pool,
                              int strip_white)
{
    apr_size_t len = 0;
    apr_text *scan;
    const apr_xml_elem *child;
    char *cdata;
    char *s;
    apr_size_t tlen;
    const char *found_text = NULL; /* initialize to avoid gcc warning */
    int found_count = 0;

    for (scan = elem->first_cdata.first; scan != NULL; scan = scan->next) {
        found_text = scan->text;
        ++found_count;
        len += strlen(found_text);
    }

    for (child = elem->first_child; child != NULL; child = child->next) {
        for (scan = child->following_cdata.first;
             scan != NULL;
             scan = scan->next) {
            found_text = scan->text;
            ++found_count;
            len += strlen(found_text);
        }
    }

    /* some fast-path cases:
     * 1) zero-length cdata
     * 2) a single piece of cdata with no whitespace to strip
     */
    if (len == 0)
        return "";
    if (found_count == 1) {
        if (!strip_white
            || (!apr_isspace(*found_text)
                && !apr_isspace(found_text[len - 1])))
            return found_text;
    }

    cdata = s = (char *)apr_palloc(pool, len + 1);

    for (scan = elem->first_cdata.first; scan != NULL; scan = scan->next) {
        tlen = strlen(scan->text);
        memcpy(s, scan->text, tlen);
        s += tlen;
    }

    for (child = elem->first_child; child != NULL; child = child->next) {
        for (scan = child->following_cdata.first;
             scan != NULL;
             scan = scan->next) {
            tlen = strlen(scan->text);
            memcpy(s, scan->text, tlen);
            s += tlen;
        }
    }

    *s = '\0';

    if (strip_white) {
        /* trim leading whitespace */
        while (apr_isspace(*cdata))     /* assume: return false for '\0' */
            ++cdata;

        /* trim trailing whitespace */
        while (len-- > 0 && apr_isspace(cdata[len]))
            continue;
        cdata[len + 1] = '\0';
    }

    return cdata;

}

static int mod_soap_handler(request_rec *r)
{
    int result;
    if (strcmp(r->handler, "mod_soap")) {
        return DECLINED;
    }
    r->content_type = "text/html";      

    Test *tt=new Test();
    ap_rprintf(r,"  %s", tt->print());
    delete tt;
    if (!r->header_only)
        ap_rputs("The sample page from mod_mod_soap.c\n", r);
    
    apr_xml_doc *doc = NULL;
    if ((result = ap_xml_parse_input(r, &doc)) != 0)
        {   ap_rputs("parse the xml false\n", r);   }
    ap_rputs(r->hostname, r); 
    ap_rputs("    ", r); 
    ap_rputs(r->method, r); 
    ap_rprintf(r,"  The return number is %d", result);
    if(doc==NULL)
    {  ap_rprintf(r,"  doc is NULL");
        return OK;
    } 
    if(doc->root==NULL)
    {
        ap_rprintf(r,"  root is NULL");
        return OK;
    }
    
    apr_xml_elem *body=soap_find_elem(doc->root, "Body");
    if(body==NULL)
    {  ap_rprintf(r,"  body is NULL");
        return OK;
    }
    
/*    if(doc->root->next==NULL)
        {
        ap_rprintf(r,"  next is NULL");
        return OK;
    }

    ap_rprintf(r," Root Name:%s  ;", doc->root->name);

    if(doc->root->first_child!=NULL)
        ap_rprintf(r," FirstChild:%s  ;", doc->root->first_child->name);

    if(doc->root->attr!=NULL)
        ap_rprintf(r," Root attr:%s : %s  ;", doc->root->attr->name, doc->root->attr->value);
    
    if(doc->root->first_child->attr!=NULL)
        ap_rprintf(r," FirstChild attr:%s :%s ;", doc->root->first_child->attr->name,doc->root->first_child->attr->value );
    ap_rputs("===========================\n", r); 
*/

    dump_xml(r,doc->root);
    return OK;
}



static void mod_soap_register_hooks(apr_pool_t *p)
{
    ap_hook_handler(mod_soap_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */

module AP_MODULE_DECLARE_DATA soap_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    mod_soap_register_hooks  /* register hooks                      */
};


